<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero Agent</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f7f7f8;
            color: #202123;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: #202123;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .sidebar-header {
            padding: 12px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .new-chat-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 16px;
            transition: all 0.2s;
        }

        .new-chat-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        #stopTtsBtn.active {
            display: block !important;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Main Chat Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
        }

        .message {
            margin-bottom: 24px;
            padding: 16px;
            border-radius: 8px;
            max-width: 100%;
            line-height: 1.6;
        }

        .message.user {
            background: #f7f7f8;
            align-self: flex-end;
        }

        .message.assistant {
            background: white;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        /* Input Area */
        .input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #e5e5e5;
        }

        .input-wrapper {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }

        .chat-input {
            width: 100%;
            padding: 12px 48px 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            outline: none;
            min-height: 24px;
            max-height: 200px;
        }

        .chat-input:focus {
            border-color: #10a37f;
        }

        .mic-btn {
            position: absolute;
            left: 60px;
            bottom: 12px;
            background: #f7f7f8;
            color: #666;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .mic-btn:hover {
            background: #e7e7e8;
        }

        .mic-btn.recording {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
            animation: pulse 1.5s infinite;
        }

        /* VAD Button */
        .vad-btn {
            position: absolute;
            left: 120px;
            bottom: 12px;
            background: #f7f7f8;
            color: #666;
            border: 1px solid #e7e7e8;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .vad-btn:hover {
            background: #e7e7e8;
        }

        .vad-btn.active {
            background: #10a37f;
            color: white;
            border-color: #10a37f;
        }

        .vad-btn.active.listening {
            animation: pulse 2s infinite;
        }

        .vad-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            transition: transform 0.2s;
        }
        
        .vad-btn.active.listening .vad-indicator {
            transform: scale(1.3);
            box-shadow: 0 0 8px currentColor;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .send-btn {
            position: absolute;
            left: 12px;
            bottom: 12px;
            background: #10a37f;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .send-btn:hover {
            background: #0d8a6a;
        }

        .send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }
        
        /* Stop Button - Phase 2: Interrupt Handling */
        .stop-btn {
            position: absolute;
            left: 12px;
            bottom: 12px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: none; /* Hidden by default */
        }
        
        .stop-btn:hover {
            background: #dc2626;
        }
        
        .stop-btn.active {
            display: block;
        }
        
        /* Speaker Button - Phase 2: Voice Output */
        .speaker-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: #f7f7f8;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s;
        }
        
        .speaker-btn:hover {
            background: #e7e7e8;
        }
        
        .speaker-btn.speaking {
            background: #10a37f;
            border-color: #10a37f;
            animation: pulse 1.5s infinite;
        }
        
        .speaker-btn.speaking svg {
            fill: white;
        }
        
        .speaker-indicator {
            font-size: 11px;
            color: #10a37f;
            margin-left: 8px;
            font-weight: 600;
            display: none;
        }
        
        .speaker-indicator.active {
            display: inline-block;
            animation: pulse 2s infinite;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Scrollbar */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }

        .chat-container::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .chat-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Welcome Message */
        .welcome {
            text-align: center;
            padding: 48px 24px;
            color: #6b7280;
        }

        .welcome h1 {
            font-size: 32px;
            color: #202123;
            margin-bottom: 16px;
        }

        .welcome p {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">Zero Agent</div>
        <button class="new-chat-btn" onclick="newChat()">+ צ'אט חדש</button>
        <button class="new-chat-btn" id="ttsToggle" onclick="toggleTTS()" style="background: #10a37f; color: white; border-color: #10a37f;">
            🔊 קול מופעל
        </button>
        <button class="new-chat-btn" id="stopTtsBtn" onclick="stopTTS()" style="background: #d9534f; color: white; border-color: #d9534f; display: none;">
            ⏸️ עצור קריאה
        </button>
    </div>

    <div class="main-content">
        <div class="chat-container" id="chatContainer">
            <div class="welcome">
                <h1>Zero Agent</h1>
                <p>איך אני יכול לעזור לך היום?</p>
            </div>
        </div>

        <div class="input-area">
            <div class="input-wrapper">
                <button class="vad-btn" id="vadBtn" onclick="toggleVAD()" title="זיהוי אוטומטי - מופעל/כבוי">
                    <div class="vad-indicator"></div>
                    <span id="vadStatus">VAD</span>
                </button>
                <button class="mic-btn" id="micBtn" onclick="toggleVoiceInput()" title="הקלטה קולית">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                </button>
                <textarea 
                    class="chat-input" 
                    id="chatInput" 
                    placeholder="שאל אותי משהו..."
                    onkeydown="handleKeyPress(event)"
                    rows="1"
                ></textarea>
                <button class="send-btn" id="sendBtn" onclick="sendMessage()">שלח</button>
                <button class="stop-btn" id="stopBtn" onclick="stopGeneration()" title="עצור ⏹️">עצור</button>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8080';
        let conversationHistory = [];
        
        // ============================================================
        // Phase 2: Interrupt Handling 🛑
        // ============================================================
        let currentAbortController = null;
        let isGenerating = false;
        
        // ============================================================
        // Phase 2: Voice Output 🔊
        // ============================================================
        let isSpeaking = false;
        let currentAudio = null;
        let ttsEnabled = true; // Auto-play TTS by default

        // ============================================================
        // TTS Functions - Voice Output 🔊
        // ============================================================
        async function speakText(text, messageId) {
            if (!ttsEnabled || !text) return;

            // Enhanced text cleaning for better TTS
            const cleaned = text
                .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                .replace(/`([^`]+)`/g, '$1')     // Remove inline code
                .replace(/https?:\/\/\S+/g, '')  // Remove URLs
                .replace(/[\*_#>]+/g, '')        // Remove markdown
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                .replace(/\n+/g, '. ')           // Convert line breaks to pauses
                .replace(/\s+/g, ' ')            // Normalize whitespace
                .trim();

            // Improved sentence splitting for better flow
            const sentences = cleaned
                .split(/(?<=[\.\!\?\:\;])\s+/)
                .filter(s => s.trim().length > 0);

            // Create chunks with better size management
            const chunks = [];
            let buffer = '';
            for (const sentence of sentences) {
                const testBuffer = buffer ? buffer + ' ' + sentence : sentence;
                
                // Use smaller chunks for better streaming (200 chars instead of 300)
                if (testBuffer.length > 200) {
                    if (buffer) {
                        chunks.push(buffer.trim());
                        buffer = sentence;
                    } else {
                        // If single sentence is too long, split it
                        const words = sentence.split(' ');
                        let tempBuffer = '';
                        for (const word of words) {
                            if ((tempBuffer + ' ' + word).trim().length > 200) {
                                if (tempBuffer) chunks.push(tempBuffer.trim());
                                tempBuffer = word;
                            } else {
                                tempBuffer = tempBuffer ? tempBuffer + ' ' + word : word;
                            }
                        }
                        buffer = tempBuffer;
                    }
                } else {
                    buffer = testBuffer;
                }
            }
            if (buffer) chunks.push(buffer.trim());
            if (chunks.length === 0) chunks.push(cleaned);

            // Check if browser TTS is available (more reliable than external service)
            const useBrowserTTS = 'speechSynthesis' in window;
            
            if (useBrowserTTS) {
                // Use Browser Speech Synthesis API (built-in, English only, but reliable)
                console.log('🔊 Using Browser Speech Synthesis API');
                
                // Load voices if not already loaded
                let voices = speechSynthesis.getVoices();
                if (voices.length === 0) {
                    // Wait for voices to load
                    await new Promise(resolve => {
                        speechSynthesis.onvoiceschanged = resolve;
                        setTimeout(resolve, 100); // Fallback timeout
                    });
                    voices = speechSynthesis.getVoices();
                }
                
                const utterance = new SpeechSynthesisUtterance(cleaned);
                utterance.lang = 'en-US';
                utterance.rate = 1.0;
                utterance.pitch = 0.9; // Slightly lower pitch for male-like voice
                utterance.volume = 1.0;
                
                // Try to find a male-sounding voice
                const maleVoice = voices.find(v => 
                    v.lang.startsWith('en') && 
                    (v.name.toLowerCase().includes('male') || 
                     v.name.toLowerCase().includes('david') ||
                     v.name.toLowerCase().includes('daniel') ||
                     v.name.toLowerCase().includes('james') ||
                     v.name.toLowerCase().includes('mark'))
                ) || voices.find(v => v.lang.startsWith('en-US') && v.localService) 
                  || voices.find(v => v.lang.startsWith('en'));
                
                if (maleVoice) {
                    utterance.voice = maleVoice;
                    console.log('🔊 Using voice:', maleVoice.name);
                } else {
                    console.log('🔊 Using default English voice');
                }
                
                isSpeaking = true;
                const stopTtsBtn = document.getElementById('stopTtsBtn');
                if (stopTtsBtn) stopTtsBtn.classList.add('active');
                
                if (messageId) {
                    const messageDiv = document.getElementById(messageId);
                    if (messageDiv) {
                        const header = messageDiv.querySelector('.message-header');
                        if (header && !header.querySelector('.speaker-indicator')) {
                            const indicator = document.createElement('span');
                            indicator.className = 'speaker-indicator active';
                            indicator.textContent = '🔊 מדבר';
                            header.appendChild(indicator);
                        }
                    }
                }
                
                await new Promise((resolve) => {
                    utterance.onend = () => {
                        isSpeaking = false;
                        const stopTtsBtn = document.getElementById('stopTtsBtn');
                        if (stopTtsBtn) stopTtsBtn.classList.remove('active');
                        if (messageId) {
                            const messageDiv = document.getElementById(messageId);
                            if (messageDiv) {
                                const indicator = messageDiv.querySelector('.speaker-indicator');
                                if (indicator) indicator.remove();
                            }
                        }
                        resolve();
                    };
                    utterance.onerror = (e) => {
                        console.error('Speech synthesis error:', e);
                        resolve();
                    };
                    
                    speechSynthesis.speak(utterance);
                });
            } else {
                // Fallback to TTS service API
                console.log('🔊 Using TTS Service API (fallback)');
                
                // Play chunks sequentially with improved flow
                for (let i = 0; i < chunks.length; i++) {
                    if (!ttsEnabled) break;
                    const part = chunks[i];
                    try {
                        console.log('🔊 TTS chunk', i + 1, 'of', chunks.length, ':', part.substring(0, 50) + '...');

                        // Add small pause between chunks for better flow
                        if (i > 0) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }

                        const resp = await fetch(`${API_URL}/api/tts?text=${encodeURIComponent(part)}&voice=male`);
                        if (!resp.ok) {
                            console.warn('TTS service unavailable');
                            break;
                        }

                        const blob = await resp.blob();
                        const url = URL.createObjectURL(blob);

                        if (currentAudio) {
                            currentAudio.pause();
                            currentAudio = null;
                        }

                        currentAudio = new Audio(url);
                        currentAudio.messageId = messageId;
                        isSpeaking = true;

                        const stopTtsBtn = document.getElementById('stopTtsBtn');
                        if (stopTtsBtn) stopTtsBtn.classList.add('active');

                        if (messageId) {
                            const messageDiv = document.getElementById(messageId);
                            if (messageDiv) {
                                const header = messageDiv.querySelector('.message-header');
                                if (header && !header.querySelector('.speaker-indicator')) {
                                    const indicator = document.createElement('span');
                                    indicator.className = 'speaker-indicator active';
                                    indicator.textContent = '🔊 מדבר';
                                    header.appendChild(indicator);
                                }
                            }
                        }

                        await new Promise((resolve, reject) => {
                            currentAudio.onended = () => {
                                URL.revokeObjectURL(url);
                                resolve();
                            };
                            currentAudio.onerror = (e) => {
                                console.error('Audio playback error:', e);
                                URL.revokeObjectURL(url);
                                resolve();
                            };
                            currentAudio.play().catch((e) => {
                                console.error('Play failed:', e);
                                URL.revokeObjectURL(url);
                                resolve();
                            });
                        });
                    } catch (e) {
                        console.warn('TTS error:', e);
                        break;
                    }
                }
            }

            isSpeaking = false;
            currentAudio = null;
            const stopTtsBtn = document.getElementById('stopTtsBtn');
            if (stopTtsBtn) stopTtsBtn.classList.remove('active');
            if (messageId) {
                const messageDiv = document.getElementById(messageId);
                if (messageDiv) {
                    const indicator = messageDiv.querySelector('.speaker-indicator');
                    if (indicator) indicator.remove();
                }
            }
        }
        
        function stopSpeaking() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                isSpeaking = false;
                console.log('🔇 TTS stopped');
            }
        }
        
        function stopTTS() {
            // Stop browser Speech Synthesis API
            if ('speechSynthesis' in window && speechSynthesis.speaking) {
                console.log('⏸️ Stopping Browser Speech Synthesis');
                speechSynthesis.cancel();
            }
            
            // Stop audio playback
            if (currentAudio) {
                console.log('⏸️ Stopping Audio TTS');
                currentAudio.pause();
                currentAudio = null;
            }
            
            isSpeaking = false;
            
            // Hide stop button
            const stopTtsBtn = document.getElementById('stopTtsBtn');
            if (stopTtsBtn) {
                stopTtsBtn.classList.remove('active');
            }
            
            // Remove all speaker indicators
            document.querySelectorAll('.speaker-indicator').forEach(indicator => {
                indicator.remove();
            });
        }

        function toggleTTS() {
            ttsEnabled = !ttsEnabled;
            const btn = document.getElementById('ttsToggle');
            
            if (ttsEnabled) {
                btn.textContent = '🔊 קול מופעל';
                btn.style.background = '#10a37f';
                btn.style.borderColor = '#10a37f';
                btn.style.color = 'white';
                console.log('✅ TTS enabled');
            } else {
                btn.textContent = '🔇 קול כבוי';
                btn.style.background = 'transparent';
                btn.style.borderColor = 'rgba(255,255,255,0.2)';
                btn.style.color = 'white';
                stopSpeaking();
                console.log('❌ TTS disabled');
            }
        }
        
        function stopGeneration() {
            console.log('🛑 Stopping generation...');
            
            if (currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
            }
            
            isGenerating = false;
            
            // Stop TTS if speaking
            stopSpeaking();
            
            // Hide stop button, show send button
            document.getElementById('stopBtn').classList.remove('active');
            document.getElementById('sendBtn').style.display = 'block';
            
            // Stop VAD recording if active
            if (vadEnabled && isRecording) {
                stopRecording();
            }
            
            console.log('✅ Generation stopped');
        }
        
        function newChat() {
            // Stop any ongoing generation
            if (isGenerating) {
                stopGeneration();
            }
            
            conversationHistory = [];
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.innerHTML = `
                <div class="welcome">
                    <h1>Zero Agent</h1>
                    <p>איך אני יכול לעזור לך היום?</p>
                </div>
            `;
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            } else if (event.key === 'Escape' && isGenerating) {
                event.preventDefault();
                stopGeneration();
            }
        }
        
        // Global escape key handler
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isGenerating) {
                stopGeneration();
            }
        });

        // ============================================================
        // STREAMING VERSION - Phase 1 Latency Improvement! ⚡
        // Phase 2: With Interrupt Handling! 🛑
        // ============================================================
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            let message = input.value.trim();
            
            // Remove surrounding quotes if user typed them
            if (message.startsWith('"') && message.endsWith('"')) {
                message = message.slice(1, -1);
                console.log('DEBUG: Removed quotes from message:', message);
            }
            
            if (!message) return;
            
            // Detect language from the message and update lastSpokenLanguage
            const detectedLang = detectLanguageFromText(message);
            if (detectedLang !== lastSpokenLanguage) {
                lastSpokenLanguage = detectedLang;
                console.log(`🎤 Language detected from message: ${detectedLang}`);
                
                // Show language detection notification
                const langName = detectedLang === 'he-IL' ? 'עברית' : 'English';
                showNotification(`Language detected: ${langName} / שפה זוהתה: ${langName}`, 'info');
            }
            
            // Don't send if already generating
            if (isGenerating) {
                console.log('⚠️ Already generating, please wait or stop');
                return;
            }

            // Clear input
            input.value = '';
            
            // Show stop button, hide send button
            isGenerating = true;
            document.getElementById('sendBtn').style.display = 'none';
            document.getElementById('stopBtn').classList.add('active');
            
            // Create new abort controller
            currentAbortController = new AbortController();
            
            // Remove welcome message
            const welcome = document.querySelector('.welcome');
            if (welcome) welcome.remove();

            // Add user message
            addMessage('user', message);

            // Add empty assistant message for streaming
            const messageId = `msg-${Date.now()}`;
            const container = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant';
            messageDiv.id = messageId;
            messageDiv.innerHTML = `
                <div class="message-header">Zero Agent</div>
                <div class="message-content"><span class="loading">מחשב</span></div>
            `;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;

            // ============================================================
            // Phase 2: Context-Aware - Add conversation history! 🧠
            // ============================================================
            // Add user message to history
            conversationHistory.push({
                role: 'user',
                content: message,
                timestamp: Date.now().toString() // Convert to string!
            });
            
            // Keep only last 10 messages (5 turns)
            if (conversationHistory.length > 10) {
                conversationHistory = conversationHistory.slice(-10);
            }
            
            // Streaming disabled - use regular chat
            try {
                // Force fallback to regular chat for now
                throw new Error('Streaming disabled - using regular chat');
                
                const response = await fetch(`${API_URL}/api/chat/stream`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message: message,
                        conversation_history: conversationHistory.slice(0, -1) // Send history without current message
                    }),
                    signal: currentAbortController.signal
                });

                if (!response.ok) {
                    throw new Error('Streaming not available, falling back to regular chat');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                let fullResponse = '';
                let isFirstChunk = true;
                const contentDiv = messageDiv.querySelector('.message-content');

                while (true) {
                    const {value, done} = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.error) {
                                    contentDiv.textContent = `שגיאה: ${data.error}`;
                                    return;
                                }
                                
                                if (data.chunk) {
                                    // Remove loading indicator on first chunk
                                    if (isFirstChunk) {
                                        contentDiv.innerHTML = '';
                                        isFirstChunk = false;
                                    }
                                    
                                    fullResponse += data.chunk;
                                    contentDiv.textContent = fullResponse;
                                    container.scrollTop = container.scrollHeight;
                                }
                                
                                if (data.done) {
                                    console.log('✅ Streaming completed');
                                    // Add assistant response to history
                                    conversationHistory.push({
                                        role: 'assistant',
                                        content: fullResponse,
                                        timestamp: Date.now()
                                    });
                                    return;
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }

            } catch (error) {
                // Check if aborted
                if (error.name === 'AbortError') {
                    console.log('🛑 Request aborted by user');
                    const contentDiv = messageDiv.querySelector('.message-content');
                    contentDiv.textContent = 'בקשה נעצרה';
                    isGenerating = false;
                    document.getElementById('stopBtn').classList.remove('active');
                    document.getElementById('sendBtn').style.display = 'block';
                    return;
                }
                
                console.warn('Streaming failed, falling back to regular chat:', error);
                
                // Fallback to regular non-streaming chat
                try {
                    const requestBody = { 
                        message: message,
                        conversation_history: conversationHistory ? conversationHistory.slice(0, -1) : []
                    };
                    
                    console.log('DEBUG: Raw message value:', message);
                    console.log('DEBUG: Message type:', typeof message);
                    console.log('DEBUG: Message length:', message.length);
                    console.log('DEBUG: Sending request body:', JSON.stringify(requestBody, null, 2));
                    console.log('DEBUG: conversationHistory type:', typeof conversationHistory);
                    console.log('DEBUG: conversationHistory value:', conversationHistory);
                    console.log('DEBUG: conversationHistory is array?', Array.isArray(conversationHistory));
                    console.log('DEBUG: conversationHistory length:', conversationHistory ? conversationHistory.length : 'undefined');
                    console.log('DEBUG: conversationHistory.slice(0, -1):', conversationHistory ? conversationHistory.slice(0, -1) : 'undefined');
                    
                    const response = await fetch(`${API_URL}/api/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                        signal: currentAbortController.signal
                    });

                    if (!response.ok) {
                        console.error('API Error:', response.status, response.statusText);
                        const errorText = await response.text();
                        console.error('Error response:', errorText);
                        throw new Error(`API Error: ${response.status} - ${errorText}`);
                    }
                    
                    const data = await response.json();
                    const contentDiv = messageDiv.querySelector('.message-content');
                    const responseText = data.response || 'מצטער, לא הצלחתי לעבד את הבקשה';
                    contentDiv.textContent = responseText;
                    
                    // Add to history
                    conversationHistory.push({
                        role: 'assistant',
                        content: responseText,
                        timestamp: Date.now().toString() // Convert to string!
                    });
                    
                    // Auto-play TTS for the response
                    await speakText(responseText, messageId);

                } catch (fallbackError) {
                    // Check if aborted
                    if (fallbackError.name === 'AbortError') {
                        console.log('🛑 Fallback request also aborted');
                        const contentDiv = messageDiv.querySelector('.message-content');
                        contentDiv.textContent = 'בקשה נעצרה';
                    } else {
                        const contentDiv = messageDiv.querySelector('.message-content');
                        contentDiv.textContent = 'שגיאה בתקשורת עם השרת';
                    }
                } finally {
                    // Always restore UI state
                    isGenerating = false;
                    document.getElementById('stopBtn').classList.remove('active');
                    document.getElementById('sendBtn').style.display = 'block';
                    currentAbortController = null;
                }
            }
        }

        function addMessage(role, content) {
            const container = document.getElementById('chatContainer');
            const messageId = `msg-${Date.now()}`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            messageDiv.id = messageId;
            
            if (role === 'user') {
                messageDiv.innerHTML = `
                    <div class="message-header">אתה</div>
                    <div>${content}</div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="message-header">Zero Agent</div>
                    <div>${content}</div>
                `;
            }

            container.appendChild(messageDiv);
            
            // Scroll to bottom
            container.scrollTop = container.scrollHeight;

            return messageId;
        }

        // Auto-resize textarea
        const textarea = document.getElementById('chatInput');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });

        // Voice Input Support
        let recognition = null;
        let isRecording = false;
        let recordingTimeout = null;
        let lastTranscriptUpdate = null;

        function initVoiceRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'en-US';  // English (auto-detect from speech)
                recognition.continuous = true;  // ✓ FIX: Allow longer recording
                recognition.interimResults = true;  // ✓ FIX: Show interim results

        recognition.onresult = (event) => {
            // Get all final + interim results
            let finalTranscript = '';
            let interimTranscript = '';
            
            for (let i = 0; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcript + ' ';
                } else {
                    interimTranscript += transcript;
                }
            }
            
            // Show interim results in real-time
            const fullTranscript = finalTranscript + interimTranscript;
            document.getElementById('chatInput').value = fullTranscript;
            console.log('🎤 Transcript:', fullTranscript);
            
            // Update last transcript update time
            lastTranscriptUpdate = Date.now();
            
            // Clear existing timeout
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
            
            // Detect language from the transcript and update settings
            if (finalTranscript.trim()) {
                const detectedLang = detectLanguageFromText(finalTranscript);
                if (detectedLang !== lastSpokenLanguage) {
                    lastSpokenLanguage = detectedLang;
                    console.log(`🎤 Language detected: ${detectedLang}`);
                }
                languageDetectionCount++;
            }
            
            // Auto-send when we have a complete sentence (ends with period, question mark, or exclamation)
            if (finalTranscript.trim() && /[.!?]$/.test(finalTranscript.trim())) {
                console.log('🎤 Auto-sending complete sentence');
                if (recordingTimeout) clearTimeout(recordingTimeout);
                setTimeout(() => {
                    sendMessage();
                }, 500); // Small delay to ensure transcription is complete
            } else if (fullTranscript.trim().length >= 3) {
                // Set timeout to auto-send after 3 seconds of silence (even without punctuation)
                recordingTimeout = setTimeout(() => {
                    const currentText = document.getElementById('chatInput').value.trim();
                    if (currentText && currentText.length >= 3 && isRecording) {
                        console.log('🎤 Auto-sending after 3s silence (no punctuation)');
                        stopRecording(true); // This will trigger auto-send
                    }
                }, 3000); // 3 seconds of silence
            }
        };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    stopRecording();
                    
                    // Handle different error types with specific messages
                    if (event.error === 'network') {
                        console.log('🌐 Network error - speech recognition unavailable');
                        console.log('💡 Switching to Faster-Whisper fallback...');
                        // Switch to Faster-Whisper instead of showing error
                        showNotification('עובר לזיהוי דיבור מקומי...', 'info');
                        setTimeout(() => {
                            startFasterWhisperRecording();
                        }, 1000);
                        return;
                    }
                    
                    if (event.error === 'not-allowed') {
                        alert('🎤 אנא אפשר גישה למיקרופון בהגדרות הדפדפן');
                    } else if (event.error === 'no-speech') {
                        console.log('🔇 No speech detected - try speaking louder');
                        showNotification('לא זוהה דיבור - נסה לדבר יותר חזק', 'info');
                    } else if (event.error === 'audio-capture') {
                        console.log('🎤 Audio capture error - check microphone');
                        showNotification('שגיאה במיקרופון - בדוק את החיבור', 'error');
                    } else {
                        console.log('❌ Speech recognition error:', event.error, '- use manual input instead');
                        showNotification('שגיאה בזיהוי דיבור - השתמש בהקלדה', 'error');
                    }
                };

                recognition.onend = () => {
                    console.log('🎤 Recognition ended');
                    // Don't auto-stop - let user control when to stop
                    if (isRecording) {
                        console.log('🎤 Restarting recognition (continuous mode)');
                        try {
                            recognition.start();
                        } catch (e) {
                            console.warn('Could not restart recognition:', e);
                            stopRecording();
                        }
                    }
                };
            } else {
                console.warn('Speech recognition not supported');
            }
        }

        function toggleVoiceInput() {
            if (!recognition) {
                initVoiceRecognition();
            }

            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        // Language detection variables
        let lastSpokenLanguage = 'en-US'; // Default to English
        let languageDetectionCount = 0;
        const maxLanguageDetection = 3; // Try both languages for first few attempts

        function detectLanguageFromText(text) {
            // Simple heuristic: if text contains Hebrew characters, it's Hebrew
            const hasHebrew = /[\u0590-\u05FF]/.test(text);
            const hasEnglish = /[a-zA-Z]/.test(text);
            
            if (hasHebrew && !hasEnglish) {
                return 'he-IL';
            } else if (hasEnglish && !hasHebrew) {
                return 'en-US';
            } else if (hasHebrew && hasEnglish) {
                // Mixed text - use more characters to decide
                const hebrewCount = (text.match(/[\u0590-\u05FF]/g) || []).length;
                const englishCount = (text.match(/[a-zA-Z]/g) || []).length;
                return hebrewCount > englishCount ? 'he-IL' : 'en-US';
            }
            
            // Default fallback
            return lastSpokenLanguage;
        }

        function startRecording() {
            if (isRecording) {
                console.log('🎤 Already recording, ignoring duplicate start');
                return;
            }
            
            if (recognition) {
                isRecording = true;
                document.getElementById('micBtn').classList.add('recording');
                document.getElementById('chatInput').placeholder = 'Listening... / מקשיב...';
                
                // Smart language detection
                let targetLang = 'en-US'; // Default to English
                
                if (languageDetectionCount < maxLanguageDetection) {
                    // For first few attempts, try both languages
                    targetLang = languageDetectionCount % 2 === 0 ? 'en-US' : 'he-IL';
                    console.log(`🎤 Language detection attempt ${languageDetectionCount + 1}: trying ${targetLang}`);
                } else {
                    // Use detected language from previous interactions
                    targetLang = lastSpokenLanguage;
                    console.log(`🎤 Using detected language: ${targetLang}`);
                }
                
                recognition.lang = targetLang;
                console.log(`🎤 Starting voice recognition with language: ${targetLang}`);
                
                try {
                    recognition.start();
                } catch (error) {
                    console.error('🎤 Error starting recognition:', error);
                    if (error.name === 'InvalidStateError') {
                        console.log('🎤 Recognition already started, stopping and restarting...');
                        recognition.stop();
                        setTimeout(() => {
                            try {
                                recognition.start();
                            } catch (e) {
                                console.error('🎤 Failed to restart recognition:', e);
                                stopRecording();
                            }
                        }, 100);
                    } else {
                        stopRecording();
                    }
                }
            } else {
                console.log('🌐 Browser STT not available, trying Faster-Whisper fallback...');
                startFasterWhisperRecording();
            }
        }

        // Faster-Whisper fallback for STT
        let mediaRecorder;
        let audioChunks = [];

        function startFasterWhisperRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showNotification('זיהוי דיבור לא נתמך בדפדפן זה', 'error');
                return;
            }

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        sendToFasterWhisper(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    document.getElementById('micBtn').classList.add('recording');
                    document.getElementById('chatInput').placeholder = 'Recording with Faster-Whisper... / מקליט עם Faster-Whisper...';
                    showNotification('הקלטה עם Faster-Whisper...', 'info');
                })
                .catch(error => {
                    console.error('Error accessing microphone:', error);
                    showNotification('שגיאה בגישה למיקרופון', 'error');
                });
        }

        function sendToFasterWhisper(audioBlob) {
            const formData = new FormData();
            formData.append('audio_file', audioBlob, 'recording.webm');

            fetch('http://localhost:9034/stt', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.transcript) {
                    document.getElementById('chatInput').value = data.transcript;
                    showNotification('זיהוי דיבור הושלם!', 'success');
                    // Auto-send if complete sentence
                    if (data.transcript.trim() && /[.!?]$/.test(data.transcript.trim())) {
                        setTimeout(() => {
                            sendMessage();
                        }, 500);
                    }
                } else {
                    showNotification('לא זוהה דיבור', 'warning');
                }
            })
            .catch(error => {
                console.error('Faster-Whisper error:', error);
                showNotification('שגיאה בזיהוי דיבור', 'error');
            });
        }

        function stopRecording(autoSend = true) {
            if (isRecording) {
                isRecording = false;
                document.getElementById('micBtn').classList.remove('recording');
                document.getElementById('chatInput').placeholder = 'שאל אותי משהו...';
                
                // Clear any pending timeout
                if (recordingTimeout) {
                    clearTimeout(recordingTimeout);
                    recordingTimeout = null;
                }
                
                if (recognition) {
                    recognition.stop();
                } else if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                
                // Auto-send after stopping recording with retry mechanism
                if (autoSend) {
                    let retryCount = 0;
                    const maxRetries = 5;
                    const retryDelay = 300; // 300ms between retries
                    
                    const tryAutoSend = () => {
                        const inputText = document.getElementById('chatInput').value.trim();
                        if (inputText && inputText.length >= 2) {
                            console.log('📤 Auto-sending message after recording:', inputText);
                            sendMessage();
                        } else if (retryCount < maxRetries) {
                            retryCount++;
                            console.log(`🔄 Retry ${retryCount}/${maxRetries} - waiting for transcript...`);
                            setTimeout(tryAutoSend, retryDelay);
                        } else {
                            console.log('⚠️ No transcript available after stopping recording');
                        }
                    };
                    
                    // Start first attempt after 500ms
                    setTimeout(tryAutoSend, 500);
                }
            }
        }

        // ============================================================
        // Voice Activity Detection (VAD) - Phase 2 Enhanced! 🎤
        // ============================================================
        let vadEnabled = false;
        let vadAudioContext = null;
        let vadAnalyser = null;
        let vadCheckInterval = null;
        let vadSpeechDetected = false;
        let vadSilenceStart = null;
        let vadStream = null;
        
        // Improved thresholds for better speech detection
        const VAD_SILENCE_THRESHOLD = -55; // dB (lower = more sensitive to silence)
        const VAD_SILENCE_DURATION = 1200; // 1.2 seconds of silence to stop
        const VAD_SPEECH_THRESHOLD = -42; // dB to start (higher = less false positives)
        const VAD_MIN_SPEECH_DURATION = 300; // Minimum 300ms of speech to trigger
        
        let vadSpeechStartTime = null;
        
        async function toggleVAD() {
            vadEnabled = !vadEnabled;
            const vadBtn = document.getElementById('vadBtn');
            const vadStatus = document.getElementById('vadStatus');
            
            if (vadEnabled) {
                // Turn ON VAD
                vadBtn.classList.add('active');
                vadStatus.textContent = 'ON';
                await startVAD();
                console.log('✅ VAD Enabled - Listening automatically...');
            } else {
                // Turn OFF VAD
                vadBtn.classList.remove('active', 'listening');
                vadStatus.textContent = 'VAD';
                stopVAD();
                console.log('❌ VAD Disabled');
            }
        }
        
        async function startVAD() {
            try {
                // Request microphone access with better audio constraints
                vadStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Setup audio context
                vadAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                vadAnalyser = vadAudioContext.createAnalyser();
                vadAnalyser.fftSize = 512; // Increased for better frequency resolution
                vadAnalyser.smoothingTimeConstant = 0.8; // Smoother transitions
                
                const source = vadAudioContext.createMediaStreamSource(vadStream);
                source.connect(vadAnalyser);
                
                // Start monitoring at higher frequency for better responsiveness
                vadCheckInterval = setInterval(checkVoiceActivity, 50);
                
                console.log('🎤 VAD monitoring started (enhanced mode)');
                
            } catch (error) {
                console.error('VAD initialization failed:', error);
                alert('לא ניתן לגשת למיקרופון. אנא אשר הרשאות.');
                vadEnabled = false;
                document.getElementById('vadBtn').classList.remove('active');
                document.getElementById('vadStatus').textContent = 'VAD';
            }
        }
        
        function stopVAD() {
            if (vadCheckInterval) {
                clearInterval(vadCheckInterval);
                vadCheckInterval = null;
            }
            
            if (vadStream) {
                vadStream.getTracks().forEach(track => track.stop());
                vadStream = null;
            }
            
            if (vadAudioContext) {
                vadAudioContext.close();
                vadAudioContext = null;
            }
            
            vadSpeechDetected = false;
            vadSilenceStart = null;
            vadSpeechStartTime = null;
        }
        
        function checkVoiceActivity() {
            if (!vadAnalyser || !vadEnabled) return;
            
            const dataArray = new Uint8Array(vadAnalyser.frequencyBinCount);
            vadAnalyser.getByteFrequencyData(dataArray);
            
            // Calculate volume with better algorithm (weighted average focusing on speech frequencies)
            let sum = 0;
            let weightedSum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                // Weight speech frequencies (roughly 100Hz-4kHz) more heavily
                const weight = (i >= 5 && i <= 80) ? 1.5 : 1.0;
                weightedSum += dataArray[i] * weight;
                sum += weight;
            }
            const average = weightedSum / sum;
            const volumeDB = 20 * Math.log10(average / 255);
            
            const vadBtn = document.getElementById('vadBtn');
            
            // Check for speech
            if (volumeDB > VAD_SPEECH_THRESHOLD) {
                // Speech detected!
                if (!vadSpeechDetected) {
                    if (!vadSpeechStartTime) {
                        vadSpeechStartTime = Date.now();
                    } else if (Date.now() - vadSpeechStartTime > VAD_MIN_SPEECH_DURATION) {
                        // Speech long enough - start recording
                        vadSpeechDetected = true;
                        vadSilenceStart = null;
                        vadBtn.classList.add('listening');
                        console.log('🗣️ Speech detected! Starting recording... (volume: ' + volumeDB.toFixed(1) + ' dB)');
                        startRecording();
                    }
                } else {
                    // Continue speech - reset silence timer
                    vadSilenceStart = null;
                }
            } else if (volumeDB < VAD_SILENCE_THRESHOLD) {
                // Silence detected
                if (vadSpeechDetected) {
                    if (!vadSilenceStart) {
                        vadSilenceStart = Date.now();
                    } else if (Date.now() - vadSilenceStart > VAD_SILENCE_DURATION) {
                        // Silence long enough - stop and send
                        vadSpeechDetected = false;
                        vadSilenceStart = null;
                        vadSpeechStartTime = null;
                        vadBtn.classList.remove('listening');
                        console.log('🔇 Silence detected. Stopping and sending...');
                        stopRecordingAndSend();
                    }
                } else {
                    // Not speaking yet - reset speech start timer
                    vadSpeechStartTime = null;
                }
            } else {
                // In between - maintain current state but reset silence timer
                if (vadSpeechDetected) {
                    vadSilenceStart = null;
                }
            }
        }
        
        function stopRecordingAndSend() {
            if (isRecording) {
                console.log('🔇 Stopping recording and sending message...');
                stopRecording();
                
                // Get the current input value
                const inputText = document.getElementById('chatInput').value.trim();
                if (inputText) {
                    console.log('📤 Auto-sending message:', inputText);
                    sendMessage();
                } else {
                    console.log('⚠️ No text to send');
                }
            }
        }
        
        // Notification system
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                max-width: 300px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideIn 0.3s ease-out;
            `;
            
            // Set colors based on type
            const colors = {
                'info': '#007bff',
                'warning': '#ffc107',
                'error': '#dc3545',
                'success': '#28a745'
            };
            notification.style.backgroundColor = colors[type] || colors.info;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Auto remove after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Initialize voice recognition on load
        window.addEventListener('load', () => {
            initVoiceRecognition();
        });
    </script>
</body>
</html>





