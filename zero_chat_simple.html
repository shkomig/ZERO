<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f7f7f8;
            color: #202123;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: #202123;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .sidebar-header {
            padding: 12px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .new-chat-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 16px;
            transition: all 0.2s;
        }

        .new-chat-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        /* Main Chat Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
        }

        .message {
            margin-bottom: 24px;
            padding: 16px;
            border-radius: 8px;
            max-width: 100%;
            line-height: 1.6;
        }

        .message.user {
            background: #f7f7f8;
            align-self: flex-end;
        }

        .message.assistant {
            background: white;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        /* Input Area */
        .input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #e5e5e5;
        }

        .input-wrapper {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            outline: none;
            min-height: 24px;
            max-height: 200px;
        }

        .chat-input:focus {
            border-color: #10a37f;
        }

        .mic-btn {
            background: #f7f7f8;
            color: #666;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .mic-btn:hover {
            background: #e7e7e8;
        }

        .mic-btn.recording {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
            animation: pulse 1.5s infinite;
        }

        /* VAD Button */
        .vad-btn {
            background: #f7f7f8;
            color: #666;
            border: 1px solid #e7e7e8;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .vad-btn:hover {
            background: #e7e7e8;
        }

        .vad-btn.active {
            background: #10a37f;
            color: white;
            border-color: #10a37f;
        }

        .vad-btn.active.listening {
            animation: pulse 2s infinite;
        }

        .vad-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            transition: transform 0.2s;
        }
        
        .vad-btn.active.listening .vad-indicator {
            transform: scale(1.3);
            box-shadow: 0 0 8px currentColor;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .send-btn {
            background: #10a37f;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .send-btn:hover {
            background: #0d8a6a;
        }

        .send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }
        
        /* Stop Button - Phase 2: Interrupt Handling */
        .stop-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: none; /* Hidden by default */
            flex-shrink: 0;
        }
        
        .stop-btn:hover {
            background: #dc2626;
        }
        
        
        /* Speaker Button - Phase 2: Voice Output */
        .speaker-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: #f7f7f8;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s;
        }
        
        .speaker-btn:hover {
            background: #e7e7e8;
        }
        
        .speaker-btn.speaking {
            background: #10a37f;
            border-color: #10a37f;
            animation: pulse 1.5s infinite;
        }
        
        .speaker-btn.speaking svg {
            fill: white;
        }
        
        .speaker-indicator {
            font-size: 11px;
            color: #10a37f;
            margin-left: 8px;
            font-weight: 600;
            display: none;
        }
        
        .speaker-indicator.active {
            display: inline-block;
            animation: pulse 2s infinite;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Scrollbar */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }

        .chat-container::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .chat-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Welcome Message */
        .welcome {
            text-align: center;
            padding: 48px 24px;
            color: #6b7280;
        }

        .welcome h1 {
            font-size: 32px;
            color: #202123;
            margin-bottom: 16px;
        }

        .welcome p {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">Zero Agent</div>
        <button class="new-chat-btn" onclick="newChat()">+ ×¦'××˜ ×—×“×©</button>
        <button class="new-chat-btn" id="ttsToggle" onclick="toggleTTS()" style="background: #10a37f; color: white; border-color: #10a37f;">
            ğŸ”Š ×§×•×œ ××•×¤×¢×œ
        </button>
    </div>

    <div class="main-content">
        <div class="chat-container" id="chatContainer">
            <div class="welcome">
                <h1>Zero Agent</h1>
                <p>××™×š ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š ×”×™×•×?</p>
            </div>
        </div>

        <div class="input-area">
            <div class="input-wrapper">
                <button class="vad-btn" id="vadBtn" onclick="toggleVAD()" title="×–×™×”×•×™ ××•×˜×•××˜×™ - ××•×¤×¢×œ/×›×‘×•×™">
                    <div class="vad-indicator"></div>
                    <span id="vadStatus">ğŸ¤ VAD ×›×‘×•×™</span>
                </button>
                <button class="mic-btn" id="micBtn" onclick="toggleVoiceInput()" title="×”×§×œ×˜×” ×§×•×œ×™×ª">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                </button>
                <textarea 
                    class="chat-input" 
                    id="chatInput" 
                    placeholder="×©××œ ××•×ª×™ ××©×”×•..."
                    onkeydown="handleKeyPress(event)"
                    rows="1"
                ></textarea>
                <button class="send-btn" id="sendBtn" onclick="sendMessage()">×©×œ×—</button>
                <button class="stop-btn" id="stopBtn" onclick="stopGeneration()" title="×¢×¦×•×¨ â¹ï¸" style="display: none;">×¢×¦×•×¨</button>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8080';
        let conversationHistory = [];
        
        // ============================================================
        // Global Variables - Must be declared first! ğŸŒ
        // ============================================================
        let vadEnabled = false;
        let isRecording = false;
        let recognition = null;
        
        // ============================================================
        // Phase 2: Interrupt Handling ğŸ›‘
        // ============================================================
        let currentAbortController = null;
        let isGenerating = false;
        
        // ============================================================
        // Phase 2: Voice Output ğŸ”Š
        // ============================================================
        let isSpeaking = false;
        let currentAudio = null;
        let ttsEnabled = true; // Auto-play TTS by default

        // ============================================================
        // TTS Functions - Voice Output ğŸ”Š
        // ============================================================
        // Advanced Web Speech API (Browser TTS) - High Quality Voice
        let synthesis = null;
        let currentUtterance = null;
        let hebrewVoice = null;
        let voiceInitialized = false;
        
        // Initialize synthesis after page loads
        document.addEventListener('DOMContentLoaded', function() {
            synthesis = window.speechSynthesis;
            console.log('ğŸ”Š Speech synthesis initialized');
        });
        
        // Initialize Hebrew voice on page load
        function initializeVoice() {
            if (voiceInitialized) return;
            
            // Check if synthesis is available
            if (!synthesis) {
                console.log('ğŸ”Š Speech synthesis not available yet, retrying...');
                setTimeout(initializeVoice, 100);
                return;
            }
            
            const voices = synthesis.getVoices();
            if (voices.length > 0) {
                // Find best Hebrew voice
                hebrewVoice = voices.find(voice => 
                    voice.lang.startsWith('he') || 
                    voice.name.includes('Hebrew') ||
                    voice.name.includes('×¢×‘×¨×™×ª')
                ) || voices.find(voice => voice.lang.startsWith('he')) || voices[0];
                
                console.log('ğŸ¤ Selected voice:', hebrewVoice ? hebrewVoice.name : 'Default');
                voiceInitialized = true;
            } else {
                // Voices not loaded yet, try again later
                setTimeout(initializeVoice, 100);
            }
        }
        
        // Initialize voice when voices are loaded
        document.addEventListener('DOMContentLoaded', function() {
            if (synthesis) {
                synthesis.onvoiceschanged = initializeVoice;
                initializeVoice();
            }
        });
        
        async function speakText(text, messageId) {
            if (!ttsEnabled || !text) {
                console.log('ğŸ”Š TTS disabled or no text:', {ttsEnabled, text: text ? text.substring(0, 20) : 'null'});
                return;
            }
            
            // Check if synthesis is available
            if (!synthesis) {
                console.log('ğŸ”Š Speech synthesis not available, skipping TTS');
                return;
            }
            
            try {
                console.log('ğŸ”Š Starting HIGH-QUALITY TTS for:', text.substring(0, 50) + '...');
                console.log('ğŸ”Š TTS Settings:', {ttsEnabled, voiceInitialized, hebrewVoice: hebrewVoice?.name});
                
                // Use Advanced Browser TTS (Web Speech API) - High Quality!
                if ('speechSynthesis' in window) {
                    // Stop current speech immediately
                    if (currentUtterance) {
                        synthesis.cancel();
                    }
                    
                    // Wait for voices to load
                    if (!voiceInitialized) {
                        await new Promise(resolve => {
                            const checkVoice = () => {
                                if (voiceInitialized) resolve();
                                else setTimeout(checkVoice, 50);
                            };
                            checkVoice();
                        });
                    }
                    
                    currentUtterance = new SpeechSynthesisUtterance(text);
                    currentUtterance.lang = 'he-IL'; // Hebrew
                    currentUtterance.rate = 0.9; // Slightly slower for clarity
                    currentUtterance.pitch = 1.1; // Slightly higher for friendliness
                    currentUtterance.volume = 1.0; // Full volume
                    
                    // Use best Hebrew voice if available
                    if (hebrewVoice) {
                        currentUtterance.voice = hebrewVoice;
                    }
                    
                    isSpeaking = true;
                    
                    // Add speaker indicator
                    if (messageId) {
                        let messageDiv = document.getElementById(messageId);
                        if (messageDiv) {
                            let header = messageDiv.querySelector('.message-header');
                            if (header && !header.querySelector('.speaker-indicator')) {
                                let indicator = document.createElement('span');
                                indicator.className = 'speaker-indicator active';
                                indicator.textContent = 'ğŸ”Š ××“×‘×¨';
                                header.appendChild(indicator);
                            }
                        }
                    }
                    
                    currentUtterance.onend = () => {
                        isSpeaking = false;
                        currentUtterance = null;
                        
                        // Remove speaker indicator
                        if (messageId) {
                            let messageDiv = document.getElementById(messageId);
                            if (messageDiv) {
                                let indicator = messageDiv.querySelector('.speaker-indicator');
                                if (indicator) {
                                    indicator.remove();
                                }
                            }
                        }
                        
                        console.log('âœ… TTS finished');
                    };
                    
                    synthesis.speak(currentUtterance);
                    console.log('âœ… Using Browser TTS (Web Speech API)');
                    console.log('ğŸ”Š Speech started with voice:', currentUtterance.voice?.name || 'Default');
                    return;
                }
                
                // Fallback: Try server TTS
                const response = await fetch(`${API_URL}/api/tts?text=${encodeURIComponent(text)}`);
                
                if (!response.ok) {
                    console.warn('TTS service unavailable, and Browser TTS not supported');
                    return;
                }
                
                // Get audio blob
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Stop current audio if playing
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }
                
                // Create and play audio
                currentAudio = new Audio(audioUrl);
                isSpeaking = true;
                
                // Add speaker indicator to message
                if (messageId) {
                    let messageDiv = document.getElementById(messageId);
                    if (messageDiv) {
                        let header = messageDiv.querySelector('.message-header');
                        if (header && !header.querySelector('.speaker-indicator')) {
                            let indicator = document.createElement('span');
                            indicator.className = 'speaker-indicator active';
                            indicator.textContent = 'ğŸ”Š ××“×‘×¨';
                            header.appendChild(indicator);
                        }
                    }
                }
                
                currentAudio.onended = () => {
                    isSpeaking = false;
                    currentAudio = null;
                    URL.revokeObjectURL(audioUrl);
                    
                    // Remove speaker indicator
                    if (messageId) {
                        let messageDiv = document.getElementById(messageId);
                        if (messageDiv) {
                            let indicator = messageDiv.querySelector('.speaker-indicator');
                            if (indicator) {
                                indicator.remove();
                            }
                        }
                    }
                    
                    console.log('âœ… TTS finished');
                };
                
                currentAudio.onerror = (e) => {
                    console.error('Audio playback error:', e);
                    isSpeaking = false;
                    currentAudio = null;
                };
                
                await currentAudio.play();
                console.log('â–¶ï¸ Playing TTS audio');
                
            } catch (error) {
                console.warn('TTS error:', error);
                isSpeaking = false;
            }
        }
        
        function stopSpeaking() {
            // Stop Web Speech API
            if (currentUtterance && synthesis) {
                synthesis.cancel();
                currentUtterance = null;
                isSpeaking = false;
                console.log('ğŸ”‡ Web Speech API stopped');
            } else if (currentUtterance && !synthesis) {
                console.log('ğŸ”‡ Web Speech API not available, clearing utterance');
                currentUtterance = null;
                isSpeaking = false;
            }
            
            // Stop audio if playing
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                isSpeaking = false;
                console.log('ğŸ”‡ Audio stopped');
            }
        }
        
        function toggleTTS() {
            ttsEnabled = !ttsEnabled;
            let btn = document.getElementById('ttsToggle');
            
            if (ttsEnabled) {
                btn.textContent = 'ğŸ”Š ×§×•×œ ××•×¤×¢×œ';
                btn.style.background = '#10a37f';
                btn.style.borderColor = '#10a37f';
                btn.style.color = 'white';
                console.log('âœ… TTS enabled');
            } else {
                btn.textContent = 'ğŸ”‡ ×§×•×œ ×›×‘×•×™';
                btn.style.background = 'transparent';
                btn.style.borderColor = 'rgba(255,255,255,0.2)';
                btn.style.color = 'white';
                stopSpeaking();
                console.log('âŒ TTS disabled');
            }
        }
        
        // Make function globally accessible
        window.stopGeneration = function() {
            console.log('ğŸ›‘ Stopping generation...');
            
            if (currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
            }
            
            isGenerating = false;
            
            // Check if buttons exist
            let sendBtn = document.getElementById('sendBtn');
            let stopBtn = document.getElementById('stopBtn');
            if (sendBtn && stopBtn) {
                sendBtn.style.display = 'block';
                stopBtn.style.display = 'none';
            }
            
            // Stop TTS if speaking
            stopSpeaking();
            
            // Stop VAD recording if active
            if (vadEnabled && isRecording) {
                stopRecording();
            }
            
            console.log('âœ… Generation stopped');
        }
        
        function newChat() {
            // Stop any ongoing generation
            if (isGenerating) {
                stopGeneration();
            }
            
            conversationHistory = [];
            let chatContainer = document.getElementById('chatContainer');
            chatContainer.innerHTML = `
                <div class="welcome">
                    <h1>Zero Agent</h1>
                    <p>××™×š ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š ×”×™×•×?</p>
                </div>
            `;
        }

        // Make function globally accessible
        window.handleKeyPress = function(event) {
            console.log('ğŸ”µ Key pressed:', event.key);
            
            // Check if input exists
            let input = document.getElementById('chatInput');
            if (!input) {
                console.error('ğŸ”´ Input element not found in handleKeyPress!');
                return;
            }
            
            if (event.key === 'Enter' && !event.shiftKey) {
                console.log('ğŸ”µ Enter pressed - calling sendMessage()');
                event.preventDefault();
                sendMessage();
            } else if (event.key === 'Escape' && isGenerating) {
                console.log('ğŸ”µ Escape pressed - calling stopGeneration()');
                event.preventDefault();
                stopGeneration();
            }
        }
        
        // Global escape key handler
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isGenerating) {
                stopGeneration();
            }
        });

        // ============================================================
        // STREAMING VERSION - Phase 1 Latency Improvement! âš¡
        // Phase 2: With Interrupt Handling! ğŸ›‘
        // ============================================================
        // Make function globally accessible
        window.sendMessage = async function() {
            console.log('ğŸ”µ sendMessage() called!');
            
            // Check if input exists
            let input = document.getElementById('chatInput');
            if (!input) {
                console.error('ğŸ”´ Input element not found!');
                return;
            }
            
            let message = input.value.trim();
            console.log('ğŸ”µ Message:', message);
            
            // Remove surrounding quotes if user typed them
            if (message.startsWith('"') && message.endsWith('"')) {
                message = message.slice(1, -1);
                console.log('DEBUG: Removed quotes from message:', message);
            }
            
            if (!message) return;
            
            // Don't send if already generating
            if (isGenerating) {
                console.log('âš ï¸ Already generating, please wait or stop');
                return;
            }

            // Clear input
            input.value = '';
            
            // Show stop button, hide send button
            isGenerating = true;
            
            let sendBtn = document.getElementById('sendBtn');
            let stopBtn = document.getElementById('stopBtn');
            if (sendBtn && stopBtn) {
                sendBtn.style.display = 'none';
                stopBtn.style.display = 'block';
            } else {
                console.error('ğŸ”´ Buttons not found!', {sendBtn, stopBtn});
            }
            
            // Create new abort controller
            currentAbortController = new AbortController();
            
            // Remove welcome message
            let welcome = document.querySelector('.welcome');
            if (welcome) welcome.remove();

            // Add user message
            addMessage('user', message);

            // Add empty assistant message for streaming
            const messageId = `msg-${Date.now()}`;
            const container = document.getElementById('chatContainer');
            let messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant';
            messageDiv.id = messageId;
            messageDiv.innerHTML = `
                <div class="message-header">Zero Agent</div>
                <div class="message-content"><span class="loading">××—×©×‘</span></div>
            `;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;

            // ============================================================
            // Phase 2: Context-Aware - Add conversation history! ğŸ§ 
            // ============================================================
            // Add user message to history
            conversationHistory.push({
                role: 'user',
                content: message,
                timestamp: Date.now().toString() // Convert to string!
            });
            
            // Keep only last 10 messages (5 turns)
            if (conversationHistory.length > 10) {
                conversationHistory = conversationHistory.slice(-10);
            }
            
            // Streaming temporarily disabled - use regular chat
            // Will enable after fixing stream_generate method
            try {
                // Force fallback to regular chat for now
                throw new Error('Streaming disabled - using regular chat');
                
                const response = await fetch(`${API_URL}/api/chat/stream`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message: message,
                        conversation_history: conversationHistory.slice(0, -1) // Send history without current message
                    }),
                    signal: currentAbortController.signal
                });

                if (!response.ok) {
                    throw new Error('Streaming not available, falling back to regular chat');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                let fullResponse = '';
                let isFirstChunk = true;
                let contentDiv = messageDiv.querySelector('.message-content');

                while (true) {
                    const {value, done} = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.error) {
                                    contentDiv.textContent = `×©×’×™××”: ${data.error}`;
                                    return;
                                }
                                
                                if (data.chunk) {
                                    // Remove loading indicator on first chunk
                                    if (isFirstChunk) {
                                        contentDiv.innerHTML = '';
                                        isFirstChunk = false;
                                    }
                                    
                                    fullResponse += data.chunk;
                                    contentDiv.textContent = fullResponse;
                                    container.scrollTop = container.scrollHeight;
                                }
                                
                                if (data.done) {
                                    console.log('âœ… Streaming completed');
                                    // Add assistant response to history
                                    conversationHistory.push({
                                        role: 'assistant',
                                        content: fullResponse,
                                        timestamp: Date.now()
                                    });
                                    return;
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }

            } catch (error) {
                // Check if aborted
                if (error.name === 'AbortError') {
                    console.log('ğŸ›‘ Request aborted by user');
                    let contentDiv = messageDiv.querySelector('.message-content');
                    contentDiv.textContent = '×‘×§×©×” × ×¢×¦×¨×”';
                    isGenerating = false;
                    
                    let sendBtn = document.getElementById('sendBtn');
                    let stopBtn = document.getElementById('stopBtn');
                    if (sendBtn && stopBtn) {
                        stopBtn.style.display = 'none';
                        sendBtn.style.display = 'block';
                    } else {
                        console.error('ğŸ”´ Buttons not found in stop handling!', {sendBtn, stopBtn});
                    }
                    
                    return;
                }
                
                console.warn('Streaming failed, falling back to regular chat:', error);
                
                // Fallback to regular non-streaming chat
                try {
                    const requestBody = { 
                        message: message,
                        conversation_history: conversationHistory ? conversationHistory.slice(0, -1) : []
                    };
                    
                    console.log('DEBUG: Raw message value:', message);
                    console.log('DEBUG: Message type:', typeof message);
                    console.log('DEBUG: Message length:', message.length);
                    console.log('DEBUG: Sending request body:', JSON.stringify(requestBody, null, 2));
                    console.log('DEBUG: conversationHistory type:', typeof conversationHistory);
                    console.log('DEBUG: conversationHistory value:', conversationHistory);
                    console.log('DEBUG: conversationHistory is array?', Array.isArray(conversationHistory));
                    console.log('DEBUG: conversationHistory length:', conversationHistory ? conversationHistory.length : 'undefined');
                    console.log('DEBUG: conversationHistory.slice(0, -1):', conversationHistory ? conversationHistory.slice(0, -1) : 'undefined');
                    
                    const response = await fetch(`${API_URL}/api/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                        signal: currentAbortController.signal
                    });

                    if (!response.ok) {
                        console.error('API Error:', response.status, response.statusText);
                        const errorText = await response.text();
                        console.error('Error response:', errorText);
                        throw new Error(`API Error: ${response.status} - ${errorText}`);
                    }
                    
                    const data = await response.json();
                    let contentDiv = messageDiv.querySelector('.message-content');
                    const responseText = data.response || '××¦×˜×¢×¨, ×œ× ×”×¦×œ×—×ª×™ ×œ×¢×‘×“ ××ª ×”×‘×§×©×”';
                    contentDiv.textContent = responseText;
                    
                    // Add to history
                    conversationHistory.push({
                        role: 'assistant',
                        content: responseText,
                        timestamp: Date.now().toString() // Convert to string!
                    });
                    
                    // Auto-play TTS for the response
                    await speakText(responseText, messageId);

                } catch (fallbackError) {
                    // Check if aborted
                    if (fallbackError.name === 'AbortError') {
                        console.log('ğŸ›‘ Fallback request also aborted');
                        let contentDiv = messageDiv.querySelector('.message-content');
                        contentDiv.textContent = '×‘×§×©×” × ×¢×¦×¨×”';
                    } else {
                        let contentDiv = messageDiv.querySelector('.message-content');
                        contentDiv.textContent = '×©×’×™××” ×‘×ª×§×©×•×¨×ª ×¢× ×”×©×¨×ª';
                    }
                } finally {
                    // Always restore UI state
                    isGenerating = false;
                    
                    let sendBtn = document.getElementById('sendBtn');
                    let stopBtn = document.getElementById('stopBtn');
                    if (sendBtn && stopBtn) {
                        stopBtn.style.display = 'none';
                        sendBtn.style.display = 'block';
                    } else {
                        console.error('ğŸ”´ Buttons not found in final error handling!', {sendBtn, stopBtn});
                    }
                    
                    currentAbortController = null;
                }
            }
        }

        function addMessage(role, content) {
            const container = document.getElementById('chatContainer');
            const messageId = `msg-${Date.now()}`;
            
            let messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            messageDiv.id = messageId;
            
            if (role === 'user') {
                messageDiv.innerHTML = `
                    <div class="message-header">××ª×”</div>
                    <div>${content}</div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="message-header">Zero Agent</div>
                    <div>${content}</div>
                `;
            }

            container.appendChild(messageDiv);
            
            // Scroll to bottom
            container.scrollTop = container.scrollHeight;

            return messageId;
        }

        // Auto-resize textarea
        const textarea = document.getElementById('chatInput');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });

        // ============================================================
        // Advanced Voice Input + VAD + Interrupt Handling ğŸ¤
        // ============================================================
        // recognition, isRecording, vadEnabled already declared at top
        let isInterrupted = false;
        let interruptionTimeout = null;
        let vadInterval = null;
        let silenceTimeout = null;
        let lastVoiceTime = 0;

        function initVoiceRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'he-IL';  // Hebrew
                recognition.continuous = false;
                recognition.interimResults = false;

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('chatInput').value = transcript;
                    stopRecording();
                    
                    // Auto-send if VAD is enabled
                    if (vadEnabled && transcript.trim()) {
                        console.log('âœ… VAD auto-sending message:', transcript);
                        setTimeout(() => sendMessage(), 100); // Small delay to ensure UI updates
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    stopRecording();
                    if (event.error === 'not-allowed') {
                        alert('×× × ××¤×©×¨ ×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ ×‘×”×’×“×¨×•×ª ×”×“×¤×“×¤×Ÿ');
                    }
                };

                recognition.onend = () => {
                    stopRecording();
                };
            } else {
                console.warn('Speech recognition not supported');
            }
        }
        
        // Voice Activity Detection (VAD) - Advanced
        function startVAD() {
            if (vadInterval) return;
            
            console.log('ğŸ¤ Starting Voice Activity Detection');
            vadInterval = setInterval(() => {
                if (isRecording && vadEnabled) {
                    const timeSinceVoice = Date.now() - lastVoiceTime;
                    
                    // If no voice for 2 seconds, stop recording
                    if (timeSinceVoice > 2000 && lastVoiceTime > 0) {
                        console.log('ğŸ¤ VAD: Silence detected, stopping recording');
                        stopRecording();
                    }
                }
            }, 500);
        }
        
        function stopVAD() {
            if (vadInterval) {
                clearInterval(vadInterval);
                vadInterval = null;
                console.log('ğŸ¤ VAD stopped');
            }
        }
        
        // Interrupt handling - stop TTS when user starts speaking
        function handleInterrupt() {
            if (isSpeaking && !isInterrupted) {
                console.log('ğŸ›‘ User interruption detected - stopping TTS');
                isInterrupted = true;
                
                // Stop current speech immediately
                if (currentUtterance) {
                    synthesis.cancel();
                }
                
                // Clear interruption flag after a delay
                if (interruptionTimeout) {
                    clearTimeout(interruptionTimeout);
                }
                interruptionTimeout = setTimeout(() => {
                    isInterrupted = false;
                    console.log('ğŸ›‘ Interrupt flag cleared');
                }, 1000);
            }
        }

        // Make function globally accessible
        window.toggleVoiceInput = function() {
            if (!recognition) {
                initVoiceRecognition();
            }

            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }
        
        // Enhanced VAD Toggle - moved to later in file

        function startRecording() {
            if (recognition) {
                // Handle interrupt if TTS is playing
                handleInterrupt();
                
                isRecording = true;
                lastVoiceTime = Date.now(); // Reset voice timer
                document.getElementById('micBtn').classList.add('recording');
                document.getElementById('chatInput').placeholder = '××§×©×™×‘...';
                recognition.start();
                
                // Start VAD if enabled
                if (vadEnabled) {
                    startVAD();
                }
                
                console.log('ğŸ¤ Started recording' + (vadEnabled ? ' with VAD' : ''));
            }
        }

        function stopRecording() {
            if (recognition && isRecording) {
                isRecording = false;
                document.getElementById('micBtn').classList.remove('recording');
                document.getElementById('chatInput').placeholder = '×©××œ ××•×ª×™ ××©×”×•...';
                recognition.stop();
                
                // Stop VAD
                stopVAD();
                
                console.log('ğŸ¤ Stopped recording');
            }
        }

        // ============================================================
        // Voice Activity Detection (VAD) - Phase 2 Enhanced! ğŸ¤
        // ============================================================
        // vadEnabled already declared at top
        let vadAudioContext = null;
        let vadAnalyser = null;
        let vadCheckInterval = null;
        let vadSpeechDetected = false;
        let vadSilenceStart = null;
        let vadStream = null;
        
        // Improved thresholds for better speech detection
        const VAD_SILENCE_THRESHOLD = -55; // dB (lower = more sensitive to silence)
        const VAD_SILENCE_DURATION = 1200; // 1.2 seconds of silence to stop
        const VAD_SPEECH_THRESHOLD = -42; // dB to start (higher = less false positives)
        const VAD_MIN_SPEECH_DURATION = 300; // Minimum 300ms of speech to trigger
        
        let vadSpeechStartTime = null;
        
        // Make function globally accessible
        window.toggleVAD = async function() {
            vadEnabled = !vadEnabled;
            let vadBtn = document.getElementById('vadBtn');
            const vadStatus = document.getElementById('vadStatus');
            
            if (vadEnabled) {
                // Turn ON VAD
                vadBtn.classList.add('active');
                vadStatus.textContent = 'ON';
                await startVAD();
                console.log('âœ… VAD Enabled - Listening automatically...');
            } else {
                // Turn OFF VAD
                vadBtn.classList.remove('active', 'listening');
                vadStatus.textContent = 'VAD';
                stopVAD();
                console.log('âŒ VAD Disabled');
            }
        }
        
        async function startVAD() {
            try {
                // Request microphone access with better audio constraints
                vadStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Setup audio context
                vadAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                vadAnalyser = vadAudioContext.createAnalyser();
                vadAnalyser.fftSize = 512; // Increased for better frequency resolution
                vadAnalyser.smoothingTimeConstant = 0.8; // Smoother transitions
                
                const source = vadAudioContext.createMediaStreamSource(vadStream);
                source.connect(vadAnalyser);
                
                // Start monitoring at higher frequency for better responsiveness
                vadCheckInterval = setInterval(checkVoiceActivity, 50);
                
                console.log('ğŸ¤ VAD monitoring started (enhanced mode)');
                
            } catch (error) {
                console.error('VAD initialization failed:', error);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××™×§×¨×•×¤×•×Ÿ. ×× × ××©×¨ ×”×¨×©××•×ª.');
                vadEnabled = false;
                document.getElementById('vadBtn').classList.remove('active');
                document.getElementById('vadStatus').textContent = 'VAD';
            }
        }
        
        function stopVAD() {
            if (vadCheckInterval) {
                clearInterval(vadCheckInterval);
                vadCheckInterval = null;
            }
            
            if (vadStream) {
                vadStream.getTracks().forEach(track => track.stop());
                vadStream = null;
            }
            
            if (vadAudioContext) {
                vadAudioContext.close();
                vadAudioContext = null;
            }
            
            vadSpeechDetected = false;
            vadSilenceStart = null;
            vadSpeechStartTime = null;
        }
        
        function checkVoiceActivity() {
            if (!vadAnalyser || !vadEnabled) return;
            
            const dataArray = new Uint8Array(vadAnalyser.frequencyBinCount);
            vadAnalyser.getByteFrequencyData(dataArray);
            
            // Calculate volume with better algorithm (weighted average focusing on speech frequencies)
            let sum = 0;
            let weightedSum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                // Weight speech frequencies (roughly 100Hz-4kHz) more heavily
                const weight = (i >= 5 && i <= 80) ? 1.5 : 1.0;
                weightedSum += dataArray[i] * weight;
                sum += weight;
            }
            const average = weightedSum / sum;
            const volumeDB = 20 * Math.log10(average / 255);
            
            let vadBtn = document.getElementById('vadBtn');
            
            // Check for speech
            if (volumeDB > VAD_SPEECH_THRESHOLD) {
                // Speech detected!
                if (!vadSpeechDetected) {
                    if (!vadSpeechStartTime) {
                        vadSpeechStartTime = Date.now();
                    } else if (Date.now() - vadSpeechStartTime > VAD_MIN_SPEECH_DURATION) {
                        // Speech long enough - start recording
                        vadSpeechDetected = true;
                        vadSilenceStart = null;
                        vadBtn.classList.add('listening');
                        console.log('ğŸ—£ï¸ Speech detected! Starting recording... (volume: ' + volumeDB.toFixed(1) + ' dB)');
                        startRecording();
                    }
                } else {
                    // Continue speech - reset silence timer
                    vadSilenceStart = null;
                }
            } else if (volumeDB < VAD_SILENCE_THRESHOLD) {
                // Silence detected
                if (vadSpeechDetected) {
                    if (!vadSilenceStart) {
                        vadSilenceStart = Date.now();
                    } else if (Date.now() - vadSilenceStart > VAD_SILENCE_DURATION) {
                        // Silence long enough - stop and send
                        vadSpeechDetected = false;
                        vadSilenceStart = null;
                        vadSpeechStartTime = null;
                        vadBtn.classList.remove('listening');
                        console.log('ğŸ”‡ Silence detected. Stopping and sending...');
                        stopRecordingAndSend();
                    }
                } else {
                    // Not speaking yet - reset speech start timer
                    vadSpeechStartTime = null;
                }
            } else {
                // In between - maintain current state but reset silence timer
                if (vadSpeechDetected) {
                    vadSilenceStart = null;
                }
            }
        }
        
        function stopRecordingAndSend() {
            if (recognition && isRecording) {
                recognition.stop();
                // The recognition.onresult will handle sending
            }
        }
        
        // Initialize voice recognition on load
        window.addEventListener('load', () => {
            initVoiceRecognition();
        });
    </script>
</body>
</html>





